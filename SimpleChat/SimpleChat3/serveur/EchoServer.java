package serveur;// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.io.*;import java.util.Observable;import java.util.Observer;//import com.sun.corba.se.spi.activation.Server;import common.ChatIF;import com.lloseng.ocsf.server.*;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. *  * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer implements Observer {	// instance variables *************************************************	ChatIF serverUI;	ObservableOriginatorServer serverObs;	// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 * 	 * @param port	 *            The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {		serverObs = new ObservableOriginatorServer(port);		serverObs.addObserver(this);		this.serverUI = serverUI;	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 * 	 * @param msg	 *            The message received from the client.	 * @param client	 *            The connection from which the message originated.	 */			public void handleMessageFromClient(Object msg, ConnectionToClient client) {		OriginatorMessage o = new OriginatorMessage(client, msg);		update(serverObs,o);	}	public void handleMessageFromServerUI(String message) {				if (message.startsWith(Character.toString('#'))) {			handleCmdServerUI(message);		} else {			serverObs.sendToAllClients("Server MSG> " + message);		}	}	public void handleCmdServerUI(String cmd) {		if (cmd.startsWith("#quit")) {			serverObs.sendToAllClients("Le serveur va maintenant etre ferme");			try {				serverObs.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			System.exit(0);		} else if (cmd.startsWith("#stop")) {			serverObs.sendToAllClients("Attention, plus de nouvelles connexions possibles");			serverObs.stopListening();		} else if (cmd.startsWith("#close")) {			serverObs.sendToAllClients("Le serveur va maintenant etre ferme");			serverObs.sendToAllClients("#logoff");			try {				serverObs.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		} else if (cmd.startsWith("#setport")) {			if (!(serverObs.isListening())) {				serverObs.setPort(Integer.parseInt(cmd.substring(9)));				serverUI.display("Le port a ete modifie");			}			else {				serverUI.display("modification impossible, Le server n'est pas arrete");			}		} else if (cmd.startsWith("#getport")) {			serverUI.display("Le port server est : " + serverObs.getPort());					} else if (cmd.startsWith("#start")) {			try {				serverObs.listen();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		}			}	public void handleCmdClient(String cmd, ConnectionToClient client) {		if (cmd.startsWith("#logoff")) {			serverUI.display("Demande de deconnexion");			try {				client.close();			} catch (IOException e) {				serverUI.display("Erreur d'IO");			}		}		else if (cmd.startsWith("#login")) {			client.setInfo("id",cmd.substring(7));		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		serverUI.display("Server listening for connections on port "				+ serverObs.getPort());	}	protected void clientConnected(ConnectionToClient client) {		serverUI.display("Un nouveau client est connecte");	}	synchronized protected void clientDisconnected(ConnectionToClient client) {		serverUI.display("Un client s'est deconnecte gentillement");	}	synchronized protected void clientException(ConnectionToClient client,			Throwable exception) {		serverUI.display("Un client s'est deconnecte brutalement");	}	/**	 * This method overrides the one in the superclass. Called when the server	 * stops listening for connections.	 */	protected void serverStopped() {		serverUI.display("Server has stopped listening for connections.");	}	// Class methods ***************************************************	public void update(Observable arg0, Object o) {		if (((OriginatorMessage)o).getMessage().toString().startsWith(Character.toString('#'))) {			handleCmdClient(((OriginatorMessage)o).getMessage().toString(), ((OriginatorMessage)o).getOriginator());		} else {			String prefixe = (String) ((OriginatorMessage)o).getOriginator().getInfo("id");			System.out.println("Message received: " + ((OriginatorMessage)o).getMessage() + " from " + prefixe);			serverObs.sendToAllClients(((OriginatorMessage)o).getMessage());		}	}}// End of EchoServer class